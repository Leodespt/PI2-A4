from Connexion import Connnection
from Portfolio import Portfolio
from Asset import Asset
from Fitness import Fitness
import random

class Population() :

    ## La population de portefeuille
    
    def __init__(self, list_portfolio, float_invest, float_volatility, float_rendement):
        self.list_portfolio=list_portfolio    #Une population est une liste de portefeuille disposant
        self.float_invest=float_invest          
        self.float_volatility=float_volatility
        self.float_rendement=float_rendement
        
        
    def crossover(self, date_test,connexion,mat):  
        It calls the mutation function to modify the population just before the return.
        '''
        sort_pop=self.sort_population()
        l=[]
        size_portfolio = len(self.list_portfolio[0].list_assets)
        size_pop=len(self.list_portfolio)
        middle_portfolio = size_portfolio//2
        i=0
        
        while i<(size_pop*3//4+1):
            portfolioo=[]
            if (i%2==0):
                j=0
                while j<middle_portfolio:
                    portfolioo.append(sort_pop.list_portfolio[i].list_assets[j])
                    j=j+1
                while j<size_portfolio:
                    portfolioo.append(sort_pop.list_portfolio[i+1].list_assets[j])
                    j=j+1
            else :
                j=0
                while j<middle_portfolio:
                    portfolioo.append(sort_pop.list_portfolio[i+1].list_assets[j])
                    j=j+1
                while j<size_portfolio:
                    portfolioo.append(sort_pop.list_portfolio[i].list_assets[j])
                    j=j+1
            i=i+1
            p_ortfolio = Portfolio(portfolioo,1)
            l.append(p_ortfolio)   
            
        nb_portfolio_random = size_pop-i
        n=0
        while n<nb_portfolio_random:
            list_asset = Asset.assign_value_assets(Asset.create_assets(connection),date_test,connection)
            portfeuille = Portfolio(list_asset,1)
            portfeuille = portfeuille.create_random_portfolio(self.max_invest)
            #portfeuille.score=Fitness.score(portfeuille,self.vola_wanted,self.rend_wanted,self.date_0,date_test,connection)
            l.append(portfeuille)
            n=n+1
        pop=Population(l, self.max_invest, self.vola_wanted, self.rend_wanted, self.date_0)
        #pop.mutation1()
        pop.mutation2()
        i=1
        for portfolio in pop.list_portfolio :
            print("Portfeuille :",i)
            portfolio.score = Fitness.score(portfolio,self.vola_wanted,self.rend_wanted,self.date_0,date_test,connection,mat)
            i=i+1
        return pop
        
        


 
    
    
    
    
    def mutation2(self):
        '''
        Function that takes as argument the object population and
        randomly modifies the number of shares of an asset of one portfolio

        it returns the modified portfolio
        '''
        portfolio_chosen = random.randint(0,len(self.list_portfolio)-1)
        asset_chosen = random.randint(0,len(self.list_portfolio[portfolio_chosen].list_assets)-1)
        a = random.randint(0,self.max_invest//(self.list_portfolio[portfolio_chosen].list_assets[asset_chosen].value*2))
        self.list_portfolio[portfolio_chosen].list_assets[asset_chosen].nb_shares= a
    
    

   


if __name__=="__main__":
    
    connection = Sql_connection('PI2','root','DFCOfoot')
    connection.initialisation()
    
    nb_portfolio=5
    max_invest=5000
    date_test="05/07/2019"
    date_0="01/07/2018"
    vola_wanted=15
    rend_wanted=10
    choix="crossover2"
    
    mat = Fitness.matrice_variation(connection, date_0, date_test)
    population_test = Population.create_population_random(nb_portfolio, max_invest, date_test,vola_wanted, rend_wanted, date_0,connection,mat)
    population_test_sort = population_test.sort_population()
    print(population_test_sort)
    population_test_next_generation = population_test_sort.crossover(choix,date_test,connection,mat)
    print(population_test_next_generation)
    #population_test_next_generation.afficher_population()
    
    
    connection.close_connection()
